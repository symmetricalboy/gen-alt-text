import iconUrl from '/icons/gen-alt-text-white.svg';
import { defineContentScript } from 'wxt/sandbox';

export default defineContentScript({
  matches: ['*://*.bsky.app/*'],
  main() {
    console.log('Bluesky Alt Text Generator loaded - V2 with FFmpeg support');
    
    if (typeof window === 'undefined' || typeof document === 'undefined') return;
    
    const ALT_TEXT_SELECTORS = [
      'textarea[aria-label="Alt text"]',
      'textarea[placeholder*="alt"]',
      'textarea[placeholder*="Alt"]',
      'textarea[data-testid*="alt"]',
      '[role="textbox"][aria-label*="alt" i]'
    ];
    const ALT_TEXT_SELECTOR = ALT_TEXT_SELECTORS.join(',');
    const BUTTON_ID = 'gemini-alt-text-button';
    const CAPTION_BUTTON_ID = 'gemini-caption-button';
    const SINGLE_FILE_DIRECT_LIMIT = 19 * 1024 * 1024; // Files smaller than this might use simplified path if needed, but prefer processLargeMedia
    const TOTAL_MEDIA_SIZE_LIMIT = 100 * 1024 * 1024; // 100MB total for a single media item

    // Port for communication with background script
    let backgroundPort: chrome.runtime.Port | null = null;
    const PORT_NAME = 'content-script-port';

    function connectToBackground() {
        if (backgroundPort && backgroundPort.sender) { // Check if port might still be valid
            try {
                // A simple message to check if it errors out
                backgroundPort.postMessage({ type: 'ping' }); 
                console.log('Background port still connected.');
                return; 
            } catch (e) {
                console.log('Background port error on ping, reconnecting...', e);
                backgroundPort = null; // Force reconnect
            }
        }

        console.log('Connecting to background script...');
        backgroundPort = browser.runtime.connect({ name: PORT_NAME });

        backgroundPort.onMessage.addListener((message: any) => {
            console.log('[ContentScript] Received message from background:', message);
            // General status/progress updates
            if (message.type === 'progress') {
                createToast(message.message, 'info', 5000);
            } else if (message.type === 'ffmpegStatus') {
                createToast(`FFmpeg: ${message.status}`, message.error ? 'error' : 'info', message.error ? 8000: 4000);
            } else if (message.type === 'ffmpegLog') {
                // console.log(`[FFMPEG BG LOG - ${message.logType}]: ${message.message}`); // Can be very noisy
            } else if (message.type === 'warning') {
                createToast(message.message, 'warning', 7000);
            } else if (message.type === 'error') {
                createToast(`Error: ${message.message}`, 'error', 10000);
                // Potentially re-enable buttons after an error, depending on the error
                // This needs careful state management based on which button was active.
                resetActiveButton(); // A generic reset for now
            } 
            // Specific result handlers are in the functions that initiate requests
        });

        backgroundPort.onDisconnect.addListener(() => {
            console.error('Disconnected from background script!', backgroundPort?.error);
            backgroundPort = null;
            // Optionally, try to reconnect after a delay
            // setTimeout(connectToBackground, 5000);
            createToast('Connection to background service lost. Please reload the extension or page.', 'error', 15000);
        });
    }

    // Initialize connection
    connectToBackground();
    
    // Define the mutation observer
    let manualModeObserver: MutationObserver | null = null;
    
    // Helper function to determine if a file should be treated as video for processing
    function isEffectivelyVideo(mimeType: string | undefined | null): boolean {
        if (!mimeType) return false;
        return mimeType.startsWith('video/') ||
               mimeType === 'image/gif' ||
               mimeType === 'image/webp' || // Assuming all webp could be animated
               mimeType === 'image/apng';
    }
    
    // Toast notification system
    const createToast = (message: string, type: 'info' | 'success' | 'error' | 'warning' = 'info', duration: number = 8000) => {
      let toastContainer = document.getElementById('gemini-toast-container');
      if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'gemini-toast-container';
        Object.assign(toastContainer.style, {
          position: 'fixed', bottom: '20px', right: '20px', zIndex: '10000',
          display: 'flex', flexDirection: 'column', gap: '10px'
        });
        document.body.appendChild(toastContainer);
      }
      
      const toast = document.createElement('div');
      Object.assign(toast.style, {
        padding: '12px 16px', borderRadius: '6px', boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)',
        margin: '5px', minWidth: '200px', color: '#ffffff', fontSize: '14px',
        transition: 'all 0.3s ease'
      });
      
      const colors = { success: '#208bfe', error: '#e53935', warning: '#f59f0b', info: '#007eda' };
      toast.style.backgroundColor = colors[type] || colors.info;
      toast.textContent = message;
      
      const closeBtn = document.createElement('span');
      closeBtn.textContent = 'Ã—';
      Object.assign(closeBtn.style, {
         marginLeft: '8px', cursor: 'pointer', float: 'right', fontWeight: 'bold'
      });
      closeBtn.onclick = () => {
        if (toast.parentNode === toastContainer) toastContainer.removeChild(toast);
      };
      toast.appendChild(closeBtn);
      
      toastContainer.appendChild(toast);
      setTimeout(() => {
        if (toast.parentNode === toastContainer) toastContainer.removeChild(toast);
      }, duration);
    };
    
    // Function to find media elements in the composer
    const findMediaElement = (container: Element): HTMLImageElement | HTMLVideoElement | null => {
      console.log('[findMediaElement - V2] Searching for media in container:', container);

      const isElementVisible = (el: Element | null): el is HTMLElement => {
          if (!el) return false;
          const rect = el.getBoundingClientRect();
          return rect.width > 0 && rect.height > 0 && (el as HTMLElement).offsetParent !== null;
      };
      
      // Add stronger video-specific selectors first
      const selectors: string[] = [
        // Video-specific selectors first for better video detection
        '[data-testid="videoPreview"] video[src]',
        '[data-testid="videos"] video[src]',
        '[data-testid="videoPreview"] video source[src]',
        '[data-testid="videos"] video source[src]',
        // More general video selectors
        'video[src]',
        'video source[src]',
        // Image selectors
        '[data-testid="imagePreview"] img[src]', 
        '[data-testid="images"] img[src]',
        'img[src]:not([alt*="avatar" i]):not([src*="avatar"])' 
      ];

      // Array to collect all visible media elements
      const visibleElements: (HTMLImageElement | HTMLVideoElement)[] = [];

      for (const selector of selectors) {
          // Get all matching elements instead of just the first one
          const elements = container.querySelectorAll<HTMLImageElement | HTMLVideoElement | HTMLSourceElement>(selector);
          
          elements.forEach(element => {
              if (element instanceof HTMLSourceElement) {
                  const videoParent = element.closest('video');
                  if (videoParent && isElementVisible(videoParent) && !visibleElements.includes(videoParent)) {
                      console.log('[findMediaElement] Found video via source element:', videoParent);
                      visibleElements.push(videoParent);
                  }
              } else if (element && isElementVisible(element) && !visibleElements.includes(element)) {
                  console.log('[findMediaElement] Found media element:', element);
                  visibleElements.push(element);
              }
          });
      }

      if (visibleElements.length > 0) {
          // Prioritize video elements if any are found
          const videoElements = visibleElements.filter(el => el instanceof HTMLVideoElement);
          if (videoElements.length > 0) {
              const video = videoElements[videoElements.length - 1];
              console.log('[findMediaElement] Found video element:', video);
              return video;
          }
          
          // Otherwise, use the last element found (likely the most recently added)
          const lastElement = visibleElements[visibleElements.length - 1];
          console.log(`[findMediaElement] Found ${visibleElements.length} media elements, using the last one:`, lastElement);
          return lastElement;
      }

      console.error('[findMediaElement] FAILED: No suitable media found using direct selectors.');
      return null;
    };

    // Function to find the composer container for a given element (e.g., textarea, media)
    const findComposerContainer = (element: Element): HTMLElement | null => {
        // Common parent containers for alt text fields or media previews
        const potentialContainers = [
            element.closest<HTMLElement>('[data-testid="composePostView"]'), // Main composer
            element.closest<HTMLElement>('[role="dialog"][aria-label*="alt text" i]'), // Alt text modal
            element.closest<HTMLElement>('[aria-label="Video settings"]'), // Video settings modal
            // Add more specific selectors if needed based on bsky.app structure
        ];

        for (const container of potentialContainers) {
            if (container) {
                console.log('[findComposerContainer] Found container:', container, 'for element:', element);
                return container;
            }
        }
        console.warn('[findComposerContainer] Could not find a known composer/dialog container for element:', element);
        return null; // Fallback if no known container is found
    };
    
    // Function to get media element source (URL or Data URL)
    // THIS FUNCTION WILL BE REPLACED/HEAVILY MODIFIED
    // Its main role will now be to get the raw File/Blob object
    const getMediaFileObject = async (mediaElement: HTMLImageElement | HTMLVideoElement): Promise<File | null> => {
      let src = '';
      if (mediaElement instanceof HTMLImageElement) {
         src = mediaElement.currentSrc || mediaElement.src;
      } else if (mediaElement instanceof HTMLVideoElement) {
         const sourceEl = mediaElement.querySelector('source');
         src = sourceEl?.src || mediaElement.src;
      }
      
      if (!src) {
          console.error('[getMediaFileObject] Media element has no discernible src attribute.', mediaElement);
          createToast('Could not find media source.', 'error');
          return null;
      }

      let fileName = 'pasted_media';
      try {
        const urlObj = new URL(src);
        fileName = urlObj.pathname.substring(urlObj.pathname.lastIndexOf('/') + 1) || fileName;
      } catch (e) { /* Not a valid URL, might be data/blob */ }
      if (!fileName.includes('.') && mediaElement.dataset.mimeType) {
          fileName += '.' + mediaElement.dataset.mimeType.split('/')[1] || 'bin';
      }

      if (src.startsWith('data:')) {
        console.log('[getMediaFileObject] Source is a Data URL. Converting to File...');
        try {
            const response = await fetch(src);
            const blob = await response.blob();
            if (blob.size > TOTAL_MEDIA_SIZE_LIMIT) {
                createToast(`File is too large (${(blob.size / (1024*1024)).toFixed(1)}MB). Max ${TOTAL_MEDIA_SIZE_LIMIT/(1024*1024)}MB.`, 'error');
                return null;
            }
            // Try to get a better filename if src was complex data uri
            const nameFromType = blob.type.replace('/', '.');
            return new File([blob], `data_url_media.${nameFromType}`, {type: blob.type});
        } catch (e) {
            console.error('[getMediaFileObject] Error converting Data URL to Blob:', e);
            createToast('Error processing pasted image data.', 'error');
            return null;
        }
      } else if (src.startsWith('blob:')) {
        console.log('[getMediaFileObject] Source is a Blob URL, fetching Blob...');
        try {
          const response = await fetch(src);
          const blob = await response.blob();
          if (blob.size > TOTAL_MEDIA_SIZE_LIMIT) {
            createToast(`File is too large (${(blob.size / (1024*1024)).toFixed(1)}MB). Max ${TOTAL_MEDIA_SIZE_LIMIT/(1024*1024)}MB.`, 'error');
            return null;
          }
          // Try to get a more descriptive name for blob if possible
          return new File([blob], fileName || `blob_media.${blob.type.replace('/', '.')}`, {type: blob.type});
        } catch (fetchError) {
          console.error('[getMediaFileObject] Error fetching Blob URL:', fetchError);
          createToast('Error accessing local media blob.', 'error');
          return null;
        }
      } else if (src.startsWith('http:') || src.startsWith('https:')) {
        console.log('[getMediaFileObject] Source is an HTTP(S) URL, fetching...');
        try {
          const response = await fetch(src); 
          if (!response.ok) {
            createToast(`Failed to fetch media (status: ${response.status}).`, 'error'); return null;
          }
          const blob = await response.blob();
          if (blob.size > TOTAL_MEDIA_SIZE_LIMIT) {
            createToast(`Remote file too large (${(blob.size / (1024*1024)).toFixed(1)}MB). Max ${TOTAL_MEDIA_SIZE_LIMIT/(1024*1024)}MB.`, 'error');
            return null;
          }
          return new File([blob], fileName, {type: blob.type});
        } catch (fetchError) {
          console.error('[getMediaFileObject] Error fetching HTTP(S) URL:', fetchError);
          createToast('Error fetching remote media.', 'error');
          return null;
        }
      } else {
        createToast(`Unsupported media source type: ${src.substring(0,30)}...`, 'error');
        return null;
      }
    };

    // Store active button to reset its text later
    let activeButtonElement: HTMLButtonElement | null = null;
    let originalButtonText: string = '';

    function setActiveButton(button: HTMLButtonElement, text: string = "Generating..."){
        if (activeButtonElement) resetButtonText(activeButtonElement, originalButtonText); // Reset previous if any
        activeButtonElement = button;
        originalButtonText = button.innerHTML;
        button.innerHTML = `<span class="loading-spinner"></span> ${text}`;
        button.disabled = true;

        // Add spinner style if not present
        if (!document.getElementById('gemini-spinner-style')) {
            const style = document.createElement('style');
            style.id = 'gemini-spinner-style';
            style.textContent = `
                .loading-spinner {
                    width: 1em; height: 1em; margin-right: 8px;
                    border: 2px solid rgba(255,255,255,0.3);
                    border-radius: 50%; border-top-color: white;
                    animation: spin 1s ease-in-out infinite; display: inline-block;
                }
                @keyframes spin { to { transform: rotate(360deg); } }
            `;
            document.head.appendChild(style);
        }
    }

    function resetButtonText(button: HTMLButtonElement | null = activeButtonElement, text: string = originalButtonText) {
        if (button) {
            button.innerHTML = text;
            button.disabled = false;
        }
        if (button === activeButtonElement) {
            activeButtonElement = null;
            originalButtonText = '';
        }
    }

    // Simplified function, specific result handlers will be inside the calling functions
    function resetActiveButton() {
        if (activeButtonElement) {
            resetButtonText(activeButtonElement, originalButtonText);
        }
    }

    // Extract video metadata
    function getVideoMetadata(mediaElement: HTMLVideoElement): any {
        if (!(mediaElement instanceof HTMLVideoElement)) return {};
        return {
            duration: mediaElement.duration,
            width: mediaElement.videoWidth,
            height: mediaElement.videoHeight
        };
    }

    // Function to add the generate button next to a textarea
    function addGenerateButton(textarea: HTMLTextAreaElement) {
      if (textarea.dataset.geminiButtonAdded === 'true') return;
      console.log('[addGenerateButton] Starting for textarea:', textarea);

      const contextContainer = findComposerContainer(textarea);
      if (!contextContainer) {
          console.error('[addGenerateButton] Could not find the context container for the textarea. Button not added.');
          return; 
      }
      console.log('[addGenerateButton] Found context container for textarea:', contextContainer);
      
      let mediaSearchContainer: Element | null = null;
      if (contextContainer.matches('[aria-label="Video settings"]')) {
          console.log('[addGenerateButton] Context is "Video settings", searching document for [data-testid="composePostView"]...');
          mediaSearchContainer = document.querySelector('[data-testid="composePostView"]'); 
          if (!mediaSearchContainer) {
               console.error('[addGenerateButton] Context is "Video settings", but failed to find [data-testid="composePostView"] in the document for media search.');
               return; 
          } 
          console.log('[addGenerateButton] Context is "Video settings", found composePostView in document for media search:', mediaSearchContainer);
      } else {
          mediaSearchContainer = contextContainer;
          // Add specific log for GIF dialog
          if (contextContainer.matches('[role="dialog"][aria-label*="alt text" i]')) {
              console.log('[addGenerateButton] Context is "Add alt text" dialog (likely GIF), targeting dialog for media search:', mediaSearchContainer);
          } else {
              console.log('[addGenerateButton] Context is likely composePostView, targeting context container for media search:', mediaSearchContainer);
          }
      }
      
      // --- START: Refine button existence check ---
      // Check if a button ALREADY exists specifically near the textarea's parent
      const buttonAttachPoint = textarea.parentElement;
      if (!buttonAttachPoint) {
          console.error('[addGenerateButton] Could not find textarea parentElement to attach button or check for existing.');
          return; 
      }
      if (buttonAttachPoint.querySelector(`#${BUTTON_ID}`)) {
         console.log('[addGenerateButton] Button already exists near the textarea attach point, marking textarea and skipping UI creation.');
         textarea.dataset.geminiButtonAdded = 'true'; 
         return;
      }
      // --- END: Refine button existence check ---
      
      const buttonContainer = document.createElement('div');
      Object.assign(buttonContainer.style, {
          display: 'flex', alignItems: 'center', gap: '8px', 
          marginTop: '4px', 
          justifyContent: 'flex-end'
      });

      const button = document.createElement('button');
      button.id = BUTTON_ID;
      button.title = 'Generate Alt Text';
      
      const icon = document.createElement('img');
      try {
        icon.src = browser.runtime.getURL(iconUrl);
      } catch (e) {
        console.error('[addGenerateButton] Error getting FULL icon URL:', e, 'Original iconUrl was:', iconUrl);
      }
      icon.alt = 'AI';
      Object.assign(icon.style, {
        width: '16px',
        height: '16px',
        marginRight: '6px'
      });

      const buttonTextNode = document.createTextNode('Generate Alt Text');
      button.innerHTML = '';
      button.appendChild(icon.cloneNode(true)); // Append a clone of the icon
      button.appendChild(buttonTextNode);
      
      Object.assign(button.style, {
          marginLeft: '8px',
          padding: '8px 16px', 
          cursor: 'pointer',
          border: 'none',
          borderRadius: '8px',
          backgroundColor: '#208bfe',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: '14px',
          fontWeight: 'bold',
          color: 'white'
      });

      // Store original style for quick reference
      const originalButtonTextContent = 'Generate Alt Text'; // Just the text
      const originalBackgroundColor = button.style.backgroundColor;
      const originalCursor = button.style.cursor;
      // Add any other styles here if they are changed during processing
      
      let isRunning = false; // Declare isRunning here

      // Helper to find the alt text area (assuming it's the one passed to addGenerateButton)
      const getAltTextArea = (): HTMLTextAreaElement => {
        return textarea;
      };

      // Helper function to generate and fill alt text
      async function generateAndFillAltText(targetTextArea: HTMLTextAreaElement) {
        if (!backgroundPort) {
            createToast('Not connected to background service. Attempting to reconnect...', 'error');
            connectToBackground(); // Attempt to reconnect
            if(!backgroundPort) {
                 createToast('Reconnect failed. Please reload the page or extension.', 'error');
                 return;
            }
        }

        const composer = findComposerContainer(targetTextArea);
        if (!composer) {
            createToast('Could not find the image/video for this alt text field.', 'error');
            return;
        }
        const mediaElement = findMediaElement(composer);
        if (!mediaElement) {
            createToast('No image or video found in the composer to generate alt text for.', 'error');
            return;
        }

        const mediaFile = await getMediaFileObject(mediaElement);
        if (!mediaFile) {
            // getMediaFileObject already shows a toast
            return;
        }

        const button = composer.querySelector(`#${BUTTON_ID}`) as HTMLButtonElement;
        if(button) setActiveButton(button, 'AI Alt Text...');
        
        let videoMeta = {};
        if (mediaElement instanceof HTMLVideoElement) {
            videoMeta = getVideoMetadata(mediaElement);
        }

        // Use a promise to handle the response from background script for this specific request
        new Promise((resolve, reject) => {
            const messageId = `altText_${Date.now()}`;
            
            const specificHandler = (message: any) => {
                if (message.originalFileName === mediaFile.name && (message.type === 'altTextResult' || message.type === 'error')) {
                    if (backgroundPort) backgroundPort.onMessage.removeListener(specificHandler); // Clean up listener
                    resetActiveButton();
                    if (message.error) {
                        reject(new Error(message.error || 'Unknown error from background for alt text'));
                    } else if (message.altText !== undefined) {
                        resolve(message.altText);
                    } else {
                        reject(new Error('Invalid alt text response from background.'));
                    }
                }
            };
            if (backgroundPort) backgroundPort.onMessage.addListener(specificHandler);
            else { reject(new Error('Background port not connected.')); return; }

            backgroundPort.postMessage({
                type: 'processLargeMedia',
                payload: {
                    file: mediaFile,
                    generationType: 'altText', 
                    videoMetadata: videoMeta,
                    messageId // Optional: for tracking, though originalFileName might be enough
                }
            });
            // Add a timeout for the specific request
            setTimeout(() => {
                if (backgroundPort) backgroundPort.onMessage.removeListener(specificHandler);
                reject(new Error('Alt text generation timed out waiting for background script response.'));
            }, 360000); // 6 minute timeout for the whole process for this request

        })
        .then(altText => {
            targetTextArea.value = altText as string;
            targetTextArea.dispatchEvent(new Event('input', { bubbles: true }));
            createToast('Alt text generated and filled!', 'success');
        })
        .catch(error => {
            console.error('Error generating alt text:', error);
            createToast(error.message, 'error');
            // Button reset is handled by the specificHandler or if button still active by general reset
            if (activeButtonElement === button) resetButtonText(button);
        });
    }

    // Find video caption section in dialog
    const findCaptionSection = (): HTMLElement | null => {
      console.log('[findCaptionSection] Searching for Video settings dialog...');
      
      // First find the dialog that contains captions section
      const dialogs = Array.from(document.querySelectorAll('div[role="dialog"]'));
      console.log('[findCaptionSection] Found', dialogs.length, 'dialogs on the page');
      
      // Log all dialogs for debugging
      dialogs.forEach((dialog, index) => {
        console.log(`[findCaptionSection] Dialog ${index}:`, dialog.getAttribute('aria-label'), dialog);
      });
      
      // More permissive selection criteria - any dialog that might be related to video
      const videoDialogs = dialogs.filter(
        el => {
          const label = el.getAttribute('aria-label');
          return label && (
            label.includes('Video') || 
            label.includes('video') || 
            label.includes('Media') || 
            label.includes('media') ||
            label.includes('Post') ||
            label.includes('Settings')
          );
        }
      );
      
      if (videoDialogs.length === 0) {
        console.log('[findCaptionSection] Could not find any potential Video dialogs');
        return null;
      }
      
      console.log('[findCaptionSection] Found potential video dialogs:', videoDialogs);
      
      // Try each dialog
      for (const dialog of videoDialogs) {
        console.log('[findCaptionSection] Examining dialog:', dialog);
        
        // Look for the "Captions (.vtt)" header or any caption-related text
        // More permissive search for any element mentioning captions
        const captionHeaders = Array.from(dialog.querySelectorAll('div, span, label, p, h1, h2, h3, h4, h5, h6'))
          .filter(el => {
            const text = el.textContent?.toLowerCase() || '';
            return text.includes('caption') || 
                   text.includes('.vtt') || 
                   text.includes('subtitle') ||
                   text.includes('cc');
          });
        
        if (captionHeaders.length > 0) {
          console.log('[findCaptionSection] Found caption-related elements in dialog:', captionHeaders);
          
          // Get the section that contains the caption UI
          const captionHeader = captionHeaders[0];
          
          // Find the parent container that wraps the captions section
          // Look up several levels to ensure we find a suitable container
          let captionSection = captionHeader;
          
          // Look for a container with file input or buttons - likely the real control section
          for (let i = 0; i < 5; i++) {
            // Check if current element or any descendant has a file input or button
            if (captionSection.querySelector('input[type="file"], button') ||
                (captionSection instanceof HTMLElement && 
                 (captionSection.querySelector('[role="button"]') || 
                  captionSection.style.display === 'flex'))) {
              console.log('[findCaptionSection] Found suitable caption control section:', captionSection);
              return captionSection as HTMLElement;
            }
            
            // Move up to parent
            if (!captionSection.parentElement) break;
            captionSection = captionSection.parentElement;
          }
          
          // Fallback - use the original caption section we found
          console.log('[findCaptionSection] Using fallback caption section:', captionSection);
          return captionSection as HTMLElement;
        }
      }
      
      console.log('[findCaptionSection] No caption section found in any dialog');
      return null;
    };
    
    // Function to add the generate captions button
    const addGenerateCaptionsButton = () => {
      console.log('[addGenerateCaptionsButton] Attempting to add Generate Captions button...');
      
      const captionSection = findCaptionSection();
      if (!captionSection) {
        console.log('[addGenerateCaptionsButton] No caption section found, skipping button creation');
        return;
      }
      console.log('[addGenerateCaptionsButton] Found caption section:', captionSection);

      if (captionSection.querySelector(`#${CAPTION_BUTTON_ID}`)) {
        console.log('[addGenerateCaptionsButton] Button already exists');
        return;
      }
      
      // Try to find an appropriate insertion point with multiple strategies
      let buttonContainer: HTMLElement | Element | null = null; // Allow Element type
      
      // Strategy 1: Look for a div with flex-direction: row
      buttonContainer = captionSection.querySelector('div[style*="flex-direction: row"], div[style*="flex-direction:row"]');
      if (buttonContainer) {
        console.log('[addGenerateCaptionsButton] Strategy 1: Found flex row container:', buttonContainer);
      }
      
      // Strategy 2: Look for any div containing a button or file input
      if (!buttonContainer) {
        const buttonContainers = Array.from(captionSection.querySelectorAll('div')).filter(
          el => el.querySelector('button, input[type="file"]')
        );
        if (buttonContainers.length > 0) {
          buttonContainer = buttonContainers[0];
          console.log('[addGenerateCaptionsButton] Strategy 2: Found container with buttons:', buttonContainer);
        }
      }
      
      // Strategy 3: Look for elements with display:flex that might be button rows
      if (!buttonContainer) {
        const flexContainers = Array.from(captionSection.querySelectorAll('div[style*="display: flex"], div[style*="display:flex"]'));
        if (flexContainers.length > 0) {
          buttonContainer = flexContainers[0];
          console.log('[addGenerateCaptionsButton] Strategy 3: Found flex container:', buttonContainer);
        }
      }
      
      // If we still couldn't find the button container, create a new one
      if (!buttonContainer) {
        console.log('[addGenerateCaptionsButton] No suitable container found, creating a new one');
        buttonContainer = document.createElement('div');
        
        const parent = captionSection.parentElement;
        if (parent && parent.firstElementChild) {
          buttonContainer.className = parent.firstElementChild.className;
        }
        
        (buttonContainer as HTMLElement).style.flexDirection = 'row';
        (buttonContainer as HTMLElement).style.display = 'flex';
        (buttonContainer as HTMLElement).style.gap = '10px';
        (buttonContainer as HTMLElement).style.marginTop = '10px';
        captionSection.appendChild(buttonContainer);
      } else {
        (buttonContainer as HTMLElement).style.display = 'flex';
        (buttonContainer as HTMLElement).style.flexDirection = 'row';
        (buttonContainer as HTMLElement).style.gap = '10px';
      }
      
      console.log('[addGenerateCaptionsButton] Using button container:', buttonContainer);
      
      const existingButton = captionSection.querySelector('button[aria-label*="subtitle file"]') || 
                             captionSection.querySelector('button') ||
                             document.querySelector('button[aria-label*="file"]') ||
                             document.querySelector('[role="button"]');
      
      console.log('[addGenerateCaptionsButton] Found existing button to style from:', existingButton);
      
      const button = document.createElement('button');
      button.id = CAPTION_BUTTON_ID;
      const icon = document.createElement('img');
      try {
        icon.src = browser.runtime.getURL(iconUrl);
      } catch (e) {
        console.error('[addGenerateCaptionsButton] Error getting FULL icon URL:', e, 'Original iconUrl was:', iconUrl);
      }
      icon.alt = 'AI';
      Object.assign(icon.style, {
        width: '16px',
        height: '16px',
        marginRight: '6px'
      });
      
      const buttonTextNode = document.createTextNode('Generate Captions');
      button.innerHTML = ''; 
      button.appendChild(icon.cloneNode(true)); // Append a clone of the icon
      button.appendChild(buttonTextNode);
      
      button.setAttribute('aria-label', 'Generate captions using AI');
      button.setAttribute('role', 'button');
      button.setAttribute('tabindex', '0');
      
      if (existingButton) {
        button.className = existingButton.className;
        const computedStyle = window.getComputedStyle(existingButton);
        Object.assign(button.style, {
          flexDirection: computedStyle.flexDirection,
          alignItems: computedStyle.alignItems,
          justifyContent: computedStyle.justifyContent,
          padding: computedStyle.padding,
          borderRadius: computedStyle.borderRadius,
          gap: computedStyle.gap,
          border: computedStyle.border,
          cursor: computedStyle.cursor,
          height: computedStyle.height,
          fontFamily: computedStyle.fontFamily,
          fontSize: computedStyle.fontSize,
          lineHeight: computedStyle.lineHeight,
          backgroundColor: '#208bfe',
          color: 'white',
          fontWeight: 'bold',
          marginLeft: '10px'
        });
      } else {
        Object.assign(button.style, {
          flexDirection: 'row',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: '#208bfe',
          padding: '13px 20px',
          borderRadius: '8px',
          gap: '8px',
          color: 'white',
          fontWeight: 'bold',
          border: 'none',
          cursor: 'pointer',
          marginLeft: '10px'
        });
      }
      
      button.addEventListener('click', generateCaptions);
      
      // --- Precise Button Placement --- 
      const subtitleButtonForPlacement = captionSection.querySelector('button[aria-label*="subtitle" i]') as HTMLElement;

      if (subtitleButtonForPlacement && subtitleButtonForPlacement.parentElement) {
        console.log('[addGenerateCaptionsButton] Precise placement: Inserting button after the found subtitle button:', subtitleButtonForPlacement);
        subtitleButtonForPlacement.insertAdjacentElement('afterend', button);
      } else if (buttonContainer instanceof HTMLElement) {
        console.log('[addGenerateCaptionsButton] Fallback placement: Appending to identified buttonContainer.');
        buttonContainer.appendChild(button);
      } else if (buttonContainer && typeof (buttonContainer as any).appendChild === 'function'){
        console.log('[addGenerateCaptionsButton] Fallback placement: Appending to Element (buttonContainer).');
        (buttonContainer as Element).appendChild(button); // Cast to Element if it has appendChild
      } else {
        console.error('[addGenerateCaptionsButton] CRITICAL: Could not find a valid container or subtitle button for placement. Appending directly to captionSection as last resort.', captionSection);
        captionSection.appendChild(button);
      }
      // createToast('Generate Captions button is now available', 'info', 5000); // Removed as per user request
      console.log('[addGenerateCaptionsButton] Added generate captions button successfully');
    };
    
    // Function to generate captions for a video
    const generateCaptions = async () => {
      try {
        // Find media element in the dialog
        const container = document.querySelector('[data-testid="composePostView"]') || document.body;
        const videoElement = findMediaElement(container);
        
        if (!videoElement || !(videoElement instanceof HTMLVideoElement)) {
          createToast('No video found to generate captions for', 'error');
          return;
        }
        
        console.log('[generateCaptions] Found video element:', videoElement);
        
        // Show loading state
        const button = document.getElementById(CAPTION_BUTTON_ID);
        if (!button) return;
        
        const originalButtonText = 'Generate Captions'; // Explicitly the text string
        button.textContent = 'Processing...'; // This can stay as it's temporary
        button.setAttribute('disabled', 'true');
        button.style.opacity = '0.7';
        
        createToast('Analyzing video to generate captions...', 'info');
        
        // Get the video source
        const mediaUrl = await getMediaFileObject(videoElement);
        if (!mediaUrl) {
          createToast('Could not access video content', 'error');
          resetButton();
          return;
        }
        
        console.log(`[generateCaptions] Got media source URL: ${mediaUrl.name}`);
        
        // Connect to background script
        const port = browser.runtime.connect({ name: "captionGenerator" });
        console.log('[generateCaptions] Connected to background script');
        
        // Set timeout to handle hanging requests
        const timeoutId = setTimeout(() => {
          port.disconnect();
          createToast('Request timed out. The video might be too large or complex to process.', 'error');
          resetButton();
        }, 300000); // 5-minute timeout
        
        // Send the request
        console.log('[generateCaptions] Sending request to background script');
        port.postMessage({
          action: 'generateCaptions',
          mediaUrl: mediaUrl,
          duration: videoElement.duration || 0
        });
        
        // Listen for response
        port.onMessage.addListener((response) => {
          clearTimeout(timeoutId);
          console.log('[generateCaptions] Received response from background script:', response);
          
          if (response.error) {
            console.error('[generateCaptions] Error from background script:', response.error);
            
            const errorMsg = response.error;
            // Check for size-related error messages and standardize them
            if (typeof errorMsg === 'string' && (
                errorMsg.toLowerCase().includes('too large') || 
                errorMsg.toLowerCase().includes('413') || 
                errorMsg.toLowerCase().includes('request entity too large') ||
                errorMsg.toLowerCase().includes('payload too large') ||
                errorMsg.toLowerCase().includes('message length exceeded') ||
                errorMsg.toLowerCase().includes('size limit'))) {
              createToast('Server error: File exceeds size limits (max 20MB). Please use a smaller file.', 'error');
            } else {
              createToast(`Error: ${errorMsg}`, 'error');
            }
            
            resetButton();
            return;
          }
          
          if (response.vttContent) {
            // Download the VTT file
            downloadVTTFile(response.vttContent);
            createToast('Captions generated and downloaded!', 'success');
            
            // Find the file input in the captions section
            const fileInput = document.querySelector('input[type="file"][accept=".vtt"]');
            if (fileInput) {
              createToast('Please select the downloaded .vtt file', 'info', 6000);
            }
          }
          
          resetButton();
        });
        
        port.onDisconnect.addListener(() => {
          clearTimeout(timeoutId);
          const lastError = browser.runtime.lastError;
          if (lastError) {
            console.error('[generateCaptions] Port disconnected with error:', lastError);
            createToast('Connection error while generating captions', 'error');
            resetButton();
          }
        });
        
        // Function to reset the button state
        function resetButton() {
          if (!button) return;
          
          button.innerHTML = ''; // Clear current content
          const resetIcon = document.createElement('img');
          try {
            resetIcon.src = browser.runtime.getURL(iconUrl); // iconUrl is from the module scope
          } catch (e) {
            console.error('[generateCaptions.resetButton] Error getting icon URL:', e);
          }
          resetIcon.alt = 'AI';
          Object.assign(resetIcon.style, { width: '16px', height: '16px', marginRight: '6px' });
          
          button.appendChild(resetIcon.cloneNode(true)); // Append a clone of the icon
          button.appendChild(document.createTextNode(originalButtonText)); // Append the original text
          
          button.removeAttribute('disabled');
          button.style.opacity = '1';
        }
      } catch (error: unknown) { // Specify unknown type for error
        console.error('[generateCaptions] Error:', error);
        createToast(`Error generating captions: ${(error instanceof Error ? error.message : String(error))}`, 'error'); // Safe access to message
        
        // Reset button state
        const button = document.getElementById(CAPTION_BUTTON_ID);
        if (button) {
          button.innerHTML = ''; // Clear current content
          const errorIcon = document.createElement('img');
          try {
            errorIcon.src = browser.runtime.getURL(iconUrl);
          } catch (e) {
            console.error('[generateCaptions.catch] Error getting icon URL:', e);
          }
          errorIcon.alt = 'AI';
          Object.assign(errorIcon.style, { width: '16px', height: '16px', marginRight: '6px' });
          
          button.appendChild(errorIcon.cloneNode(true)); // Append a clone of the icon
          button.appendChild(document.createTextNode('Generate Captions')); // Append the original text
          
          button.removeAttribute('disabled');
          button.style.opacity = '1';
        }
      }
    };
    
    // Helper function to download the VTT file
    const downloadVTTFile = (vttContent: string) => {
      const filename = `captions-${Date.now()}.vtt`;
      const blob = new Blob([vttContent], { type: 'text/vtt' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      
      // Clean up
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    };
    
    // Modified MutationObserver to look for caption sections too
    const observeAltTextAreas = () => {
      if (manualModeObserver) manualModeObserver.disconnect(); 
      console.log('[observeAltTextAreas] Starting observer for manual button injection.');
      
      document.querySelectorAll<HTMLTextAreaElement>(ALT_TEXT_SELECTOR).forEach(addGenerateButton);
      
      // Also check for caption sections on initial load
      // Try multiple times to handle dynamic UI loading
      addGenerateCaptionsButton();
      setTimeout(addGenerateCaptionsButton, 500);  // First attempt shortly after load
      setTimeout(addGenerateCaptionsButton, 2000); // Second attempt after 2 seconds
      setTimeout(addGenerateCaptionsButton, 5000); // Third attempt after 5 seconds

      manualModeObserver = new MutationObserver((mutations) => {
        // Keep track if we've detected a likely dialog change that might contain captions
        let shouldCheckForCaptions = false;
        
        for (const mutation of mutations) {
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(node => {
              if (node instanceof HTMLElement) {
                // Handle alt text areas
                if (node.matches(ALT_TEXT_SELECTOR)) {
                   addGenerateButton(node as HTMLTextAreaElement);
                }
                node.querySelectorAll<HTMLTextAreaElement>(ALT_TEXT_SELECTOR)
                  .forEach(addGenerateButton);
                  
                // Detect dialog additions and video-related elements
                if (node.matches('div[role="dialog"]') || 
                    node.getAttribute('aria-label')?.includes('Video') || 
                    node.getAttribute('aria-label')?.includes('video') || 
                    node.querySelector('video')) {
                  console.log('[MutationObserver] Detected new dialog or video element:', node);
                  shouldCheckForCaptions = true;
                }
                
                // Look for captions sections by content
                if (node.textContent?.includes('Captions') || 
                    node.textContent?.includes('.vtt') || 
                    node.textContent?.includes('subtitle') || 
                    node.innerHTML?.includes('caption') ||
                    node.querySelector('input[type="file"][accept*=".vtt"]')) {
                  console.log('[MutationObserver] Detected possible caption-related element:', node);
                  shouldCheckForCaptions = true;
                }
                
                // Check for video elements being added
                if (node.tagName === 'VIDEO' || node.querySelector('video')) {
                  console.log('[MutationObserver] Video element detected:', node);
                  shouldCheckForCaptions = true;
                }
              }
            });
          }
          // Check for attribute changes on dialogs or video containers
          if (mutation.type === 'attributes' && 
              mutation.target instanceof HTMLElement && 
              (mutation.target.matches('div[role="dialog"]') ||
               mutation.target.querySelector('video'))) {
            console.log('[MutationObserver] Detected attribute change on dialog or video container:', mutation.target);
            shouldCheckForCaptions = true;
          }
          
          // Alt text area handling (keep existing code)
          if (mutation.type === 'attributes' && 
              mutation.target instanceof HTMLElement && 
              mutation.target.matches(ALT_TEXT_SELECTOR)) {
             addGenerateButton(mutation.target as HTMLTextAreaElement);
          }
        }
        
        // If we detected any changes that might involve captions, try to add the button
        if (shouldCheckForCaptions) {
          console.log('[MutationObserver] Detected potential caption-related changes, attempting to add button');
          // Use a timeout to let the UI stabilize
          setTimeout(addGenerateCaptionsButton, 300);
          // Try again a bit later in case the first attempt was too early
          setTimeout(addGenerateCaptionsButton, 1000);
        }
      });

      manualModeObserver.observe(document.body, { 
          childList: true, 
          subtree: true, 
          attributes: true, 
          attributeFilter: ['aria-label', 'placeholder', 'data-testid', 'role', 'style', 'class'] 
      });
      console.log('[observeAltTextAreas] Observer attached to document body.');
    };
    
    // --- Start Observer Directly ---
    // Ensure DOM is ready before starting
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', observeAltTextAreas);
    } else {
        observeAltTextAreas();
    }
    // --- END: Start Observer Directly ---
    
    console.log('Bluesky Alt Text Generator content script setup complete.');
  },
});